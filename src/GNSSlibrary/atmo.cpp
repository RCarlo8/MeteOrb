#include <iostream>
#include <armadillo>
#include <fstream>
#include <string>
#include <vector>
#include <sstream>

#include "atmo.h"
#include "utility.h"

using namespace std;
using namespace arma;


Atmo::Atmo(){};
Atmo::~Atmo(){};

vec Atmo::klobuchar(double lat, double lon, vec az, vec el, double sow, vec ionoparams) {
    // define number of satellite from observation
    int n_sat = max(size(az));
    // initialize result
    vec delay;
    delay.zeros(n_sat);

    // light speed constant
    double V_LIGHT = datum::c_0;

    // ionospheric parameters
    double a0 = ionoparams(0);
    double a1 = ionoparams(1);
    double a2 = ionoparams(2);
    double a3 = ionoparams(3);
    double b0 = ionoparams(4);
    double b1 = ionoparams(5);
    double b2 = ionoparams(6);
    double b3 = ionoparams(7);

    // elevation from 0 to 90 degrees
    el = abs(el);
    //conversion to semicircles
    lat = lat / 180;
    lon = lon / 180;
    az = az / 180;
    el = el / 180;

    vec f = 1 + 16 * (pow((0.53 - el),3));
    vec psi = (0.0137 /(el + 0.11)) - 0.022;
    vec phi = lat + (psi % cos(az*pi));

    for (int i = 0; i < n_sat; i++)
    {
        if(phi(i) > 0.416) phi(i) = 0.416;
        if(phi(i) < -0.416) phi(i) = -0.416;
    }

    vec lambda = lon + ((psi % sin(az*pi)) / cos(phi*pi));
    vec ro = phi + 0.064 * cos((lambda-1.617)*pi);
    vec t = lambda*43200 + sow;
    t = t - 86400 * floor(t/86400);
    vec a = a0 + a1*ro + a2*pow(ro,2) + a3*pow(ro,3);

    for (int i = 0; i < n_sat; i++)
    {
        if(a(i) < 0) a(i) = 0;
    }
    
    vec p = b0 + b1*ro + b2*pow(ro,2) + b3*pow(ro,3);
    
    for (int i = 0; i < n_sat; i++)
    {
        if(p(i) < 72000) p(i) = 72000;
    }

    vec x = (2*pi*(t - 50400)) / p;
    
    //ionospheric delay

    for (int i = 0; i < n_sat; ++i)
        {
            if(abs(x(i)) < 1.57) {
            delay(i) = V_LIGHT * f(i) * (5e-9 + a(i) * (1- (pow(x(i),2)/2 + pow(x(i),4)/24)));
            }

            if(abs(x(i)) >= 1.57) {
            delay(i) = V_LIGHT * f(i) * 5e-9;
            }
        }
    return delay;
}

vec Atmo::saastamoinen(vec el, double h){
    
    double STD_TEMP = 291.15;
    double STD_PRES = 1013.25;
    double STD_HUMI = 50;

    int n_sat = max(size(el));
    vec delay(n_sat);

    if (h < 5000)
    {
        el = abs(el);
        double P = STD_PRES * pow((1-0.0000226*h),5.225);
        double T = STD_TEMP - 0.0065*h;
        double H = STD_HUMI * exp(-0.0006396*h);
      
    
        vec h_a = {0, 500, 1000, 1500, 2000, 2500, 3000, 4000, 5000};
        vec B_a = {1.156, 1.079, 1.006, 0.938, 0.874, 0.813, 0.757, 0.654, 0.563};

        double t;
        double B;
        vec index(2);
        int a;
        int b;
      
        vec d = h_a - h;
        int j = index_min(abs(d)); 

        if(d(j) > 0) { // a prec e b succ
            a = j-1;
            b = j;
        } else {
            a = j;
            b = j+1;
        }

        t = (h - h_a(a)) / (h_a(b) - h_a(a));
        B = (1-t)*B_a(a) + t * B_a(b);

        double e = 0.01 * H * exp(-37.2465 + 0.213166*T - 0.000256908*pow(T,2));
        vec w_fun = (1 - pow(tan(el),2) / (pow(tan(el),2) + pow(tan(el+2),2)));

        for (int i = 0; i < n_sat; ++i){
            
            delay[i] = ((0.002277 / sin(el[i])) * (P - (B / (pow(tan(el[i]),2) +0.01*w_fun[i]))) + (0.002277 / sin(el[i])) * (1255 / T + 0.05) * e );
        }
        
    } else { 
        
        delay.zeros(max(size(el)));
    }
     
    return delay;
}

tuple<vec,vec> Atmo::gmf(double timeMJD, double lat, double lon, double hgt, vec el) {
    
    vec gmfh,gmfw;
    field<vec> result(2);

    double doy = timeMJD  - 44239 + 1;
    //pi = 3.14159265359;

    bool cached = (lon == this->lon) && (lat == this->lat) && (datum::nan == this->ahm) && (datum::nan==this->aha);

    if(cached) {

        mat W = this->W;
        mat V = this->V;

        double ahm = this->ahm;
        double aha = this->aha; 
        double awm = this->awm;
        double awa = this->awa;

    } else {

        vec ah_mean = {     125.170000000000,0.850300000000000,0.0693600000000000,-6.76000000000000,0.177100000000000,
                        0.0113000000000000,0.596300000000000,0.0180800000000000,0.00280100000000000,-0.00141400000000000,
                        -1.21200000000000,0.0930000000000000,0.00368300000000000,0.00109500000000000,4.67100000000000e-05,
                        0.395900000000000,-0.0386700000000000,0.00541300000000000,-0.000528900000000000,0.000322900000000000,
                        2.06700000000000e-05,0.300000000000000,0.0203100000000000,0.00590000000000000,0.000457300000000000,
                        -7.61900000000000e-05,2.32700000000000e-06,3.84500000000000e-06,0.118200000000000,0.0115800000000000,
                        0.00544500000000000,6.21900000000000e-05,4.20400000000000e-06,-2.09300000000000e-06,1.54000000000000e-07,
                        -4.28000000000000e-08,-0.475100000000000,-0.0349000000000000,0.00175800000000000,0.000401900000000000,
                        -2.79900000000000e-06,-1.28700000000000e-06,5.46800000000000e-07,7.58000000000000e-08,-6.30000000000000e-09,
                        -0.116000000000000,0.00830100000000000,0.000877100000000000,9.95500000000000e-05,-1.71800000000000e-06,
                        -2.01200000000000e-06,1.17000000000000e-08,1.79000000000000e-08,-1.30000000000000e-09,1.00000000000000e-10,
    }; 


    vec bh_mean = {     0,	0,	0.0324900000000000,	0,	0.0332400000000000,	
                        0.0185000000000000,	0,	-0.111500000000000,	0.0251900000000000,	0.00492300000000000,
                        0,	0.0273700000000000,	0.0159500000000000,	-0.000733200000000000,	0.000193300000000000,
                        0,	-0.0479600000000000,	0.00638100000000000,	-0.000159900000000000,	-0.000368500000000000,
                        1.81500000000000e-05,	0,	0.0703300000000000,	0.00242600000000000,	-0.00111100000000000,
                        -0.000135700000000000,	-7.82800000000000e-06,	2.54700000000000e-06,	0,	0.00577900000000000,
                        0.00313300000000000,	-0.000531200000000000,	-2.02800000000000e-05,	2.32300000000000e-07,	-9.10000000000000e-08,
                        -1.65000000000000e-08,	0,	0.0368800000000000,	-0.000863800000000000,	-8.51400000000000e-05,
                    	-2.82800000000000e-05,	5.40300000000000e-07,	4.39000000000000e-07,	1.35000000000000e-08,	1.80000000000000e-09,	
                        0,	-0.0273600000000000,	-0.000297700000000000,	8.11300000000000e-05,	2.32900000000000e-07,
                        8.45100000000000e-07,	4.49000000000000e-08,	-8.10000000000000e-09,	-1.50000000000000e-09,	2.00000000000000e-10
    };


    vec ah_amp = {      -0.273800000000000,	-2.83700000000000,	0.0129800000000000,	-0.358800000000000,	0.0241300000000000,
    	                0.0342700000000000,	-0.762400000000000,	0.0727200000000000,	0.0216000000000000,	-0.00338500000000000,
        	            0.442400000000000,	0.0372200000000000,	0.0219500000000000,	-0.00150300000000000,	0.000242600000000000,
            	        0.301300000000000,	0.0576200000000000,	0.0101900000000000,	-0.000447600000000000,	6.79000000000000e-05,
                	    3.22700000000000e-05,	0.312300000000000,	-0.0353500000000000,	0.00484000000000000,	3.02500000000000e-06,
                    	-4.36300000000000e-05,	2.85400000000000e-07,	-1.28600000000000e-06,	-0.672500000000000,	-0.0373000000000000,
                        0.000896400000000000,	0.000139900000000000,	-3.99000000000000e-06,	7.43100000000000e-06,	-2.79600000000000e-07,
                        -1.60100000000000e-07,	0.0406800000000000,	-0.0135200000000000,	0.000728200000000000,	9.59400000000000e-05,
                        2.07000000000000e-06,	-9.62000000000000e-08,	-2.74200000000000e-07,	-6.37000000000000e-08,	-6.30000000000000e-09,
                        0.0862500000000000,	-0.00597100000000000,	0.000470500000000000,	2.33500000000000e-05,	4.22600000000000e-06,
    	                2.47500000000000e-07,	-8.85000000000000e-08,	-3.60000000000000e-08,	-2.90000000000000e-09,	0
    };


    vec bh_amp = {      0,	0,	-0.113600000000000,	0,	-0.186800000000000,
    	                -0.0139900000000000,	0,	-0.104300000000000,	0.0117500000000000,	-0.00224000000000000,
        	            0,	-0.0322200000000000,	0.0133300000000000,	-0.00264700000000000,	-2.31600000000000e-05,
            	        0,	0.0533900000000000,	0.0110700000000000,	-0.00311600000000000,	-0.000107900000000000,
                	    -1.29900000000000e-05,	0,	0.00486100000000000,	0.00889100000000000,	-0.000644800000000000,
                    	-1.27900000000000e-05,	6.35800000000000e-06,	-1.41700000000000e-07,	0,	0.0304100000000000,
                        0.00115000000000000,	-0.000874300000000000,	-2.78100000000000e-05,	6.36700000000000e-07,	-1.14000000000000e-08,
                        -4.20000000000000e-08,	0,	-0.0298200000000000,	-0.00300000000000000,	1.39400000000000e-05,
                        -3.29000000000000e-05,	-1.70500000000000e-07,	7.44000000000000e-08,	2.72000000000000e-08,	-6.60000000000000e-09,
                        0,	0.0123600000000000,	-0.000998100000000000,	-3.79200000000000e-05,	-1.35500000000000e-05,
                        1.16200000000000e-06,	-1.78900000000000e-07,	1.47000000000000e-08,	-2.40000000000000e-09,	-4.00000000000000e-10
    };           
                
    
    vec aw_mean = {     56.4000000000000,	1.55500000000000,	-1.01100000000000,	-3.97500000000000,	0.0317100000000000,
                        0.106500000000000,	0.617500000000000,	0.137600000000000,	0.0422900000000000,	0.00302800000000000,
                        1.68800000000000,	-0.169200000000000,	0.0547800000000000,	0.0247300000000000,	0.000605900000000000,	
                        2.27800000000000,	0.00661400000000000, -0.000350500000000000,	-0.00669700000000000,	0.000840200000000000,	
                        0.000703300000000000,	-3.23600000000000,	0.218400000000000,	-0.0461100000000000,	-0.0161300000000000,
                        -0.00160400000000000,	5.42000000000000e-05,	7.92200000000000e-05,	-0.271100000000000,	-0.440600000000000,	
                        -0.0337600000000000,	-0.00280100000000000,	-0.000409000000000000,	-2.05600000000000e-05,	6.89400000000000e-06,	
                        2.31700000000000e-06,	1.94100000000000,	-0.256200000000000,	0.0159800000000000,	0.00544900000000000,	
                        0.000354400000000000,	1.14800000000000e-05,	7.50300000000000e-06,	-5.66700000000000e-07,	-3.66000000000000e-08,	
                        0.868300000000000,	-0.0593100000000000,	-0.00186400000000000,	-0.000127700000000000,	0.000202900000000000,	
                        1.26900000000000e-05,	1.62900000000000e-06,	9.66000000000000e-08,	-1.01500000000000e-07,	-5.00000000000000e-10
    };
                

    vec bw_mean = {     0,	0,	0.259200000000000,	0,	0.0297400000000000,
    	                -0.547100000000000,	0,	-0.592600000000000,	-0.103000000000000,	-0.0156700000000000,
        	            0,	0.171000000000000,	0.0902500000000000,	0.0268900000000000,	0.00224300000000000,
            	        0,	0.343900000000000,	0.0240200000000000,	0.00541000000000000,	0.00160100000000000,
                	    9.66900000000000e-05,	0,	0.0950200000000000,	-0.0306300000000000,	-0.00105500000000000,
                    	-0.000106700000000000,	-0.000113000000000000,	2.12400000000000e-05,	0,	-0.312900000000000,
                        0.00846300000000000,	0.000225300000000000,	7.41300000000000e-05,	-9.37600000000000e-05,	-1.60600000000000e-06,
                        2.06000000000000e-06,	0,	0.273900000000000,	0.00116700000000000,	-2.24600000000000e-05,
                        -0.000128700000000000,	-2.43800000000000e-05,	-7.56100000000000e-07,	1.15800000000000e-06,	4.95000000000000e-08,
                        0,	-0.134400000000000,	0.00534200000000000,	0.000377500000000000,	-6.75600000000000e-05,
                        -1.68600000000000e-06,	-1.18400000000000e-06,	2.76800000000000e-07,	2.73000000000000e-08,	5.70000000000000e-09

    };           


    vec aw_amp = {      0.102300000000000,	-2.69500000000000,	0.341700000000000,	-0.140500000000000,	0.317500000000000,
    	                0.211600000000000,	3.53600000000000,	-0.150500000000000,	-0.0166000000000000,	0.0296700000000000,	
                        0.381900000000000,	-0.169500000000000,	-0.0744400000000000,	0.00740900000000000,	-0.00626200000000000,	
                        -1.83600000000000,	-0.0175900000000000,	-0.0625600000000000,	-0.00237100000000000,	0.000794700000000000,	
                        0.000150100000000000,	-0.860300000000000,	-0.136000000000000,	-0.0362900000000000,	-0.00370600000000000,	
                        -0.000297600000000000,	1.85700000000000e-05,	3.02100000000000e-05,	2.24800000000000,	-0.117800000000000,	
                        0.0125500000000000,	0.00113400000000000,	-0.000216100000000000,	-5.81700000000000e-06,	8.83600000000000e-07,	
                        -1.76900000000000e-07,	0.731300000000000,	-0.118800000000000,	0.0114500000000000,	0.00101100000000000,	
                        0.000108300000000000,	2.57000000000000e-06,	-2.14000000000000e-06,	-5.71000000000000e-08,	2.00000000000000e-08,	
                        -1.63200000000000,	-0.00694800000000000,	-0.00389300000000000,	0.000859200000000000,	7.57700000000000e-05,	
                        4.53900000000000e-06,	-3.85200000000000e-07,	-2.21300000000000e-07,	-1.37000000000000e-08,	5.80000000000000e-09
    };           
                

    vec bw_amp = {      0,	0,	-0.113600000000000,	0,	-0.186800000000000,
    	                -0.0139900000000000,	0,	-0.104300000000000,	0.0117500000000000,	-0.00224000000000000,
                        0,	-0.0322200000000000, 0.0133300000000000,	-0.00264700000000000,	-2.31600000000000e-05,	
                        0,	0.0533900000000000,	0.0110700000000000,	-0.00311600000000000,	-0.000107900000000000,
            	        -1.29900000000000e-05,	0,	0.00486100000000000,	0.00889100000000000,	-0.000644800000000000,
                	    -1.27900000000000e-05,	6.35800000000000e-06,	-1.41700000000000e-07,	0,	0.0304100000000000,
                    	0.00115000000000000,	-0.000874300000000000,	-2.78100000000000e-05,	6.36700000000000e-07,	-1.14000000000000e-08,
                        -4.20000000000000e-08,	0,	-0.0298200000000000,	-0.00300000000000000,	1.39400000000000e-05,
                        -3.29000000000000e-05,	-1.70500000000000e-07,	7.44000000000000e-08,	2.72000000000000e-08,	-6.60000000000000e-09,
                        0,	0.0123600000000000,	-0.000998100000000000,	-3.79200000000000e-05,	-1.35500000000000e-05,
                        1.16200000000000e-06,	-1.78900000000000e-07,	1.47000000000000e-08,	-2.40000000000000e-09,	-4.00000000000000e-10
        
    };   

    //degree n and order m
    int nmax = 9;
                
                
    // unit vector
    double x = cos(lat)*cos(lon);
    double y = cos(lat)*sin(lon);
    double z = sin(lat);
                
    mat V = zeros(nmax + 1,nmax + 1);
    mat W = zeros(nmax + 1,nmax + 1);


    // Legendre polynomials
    V(0,0) = 1.0;
    W(0,0) = 0.0;
    V(1,0) = z * V(0,0);
    W(1,0) = 0.0;
    
    for (int n = 1; n < nmax; n++)
    {
        V(n+1,0) = ((2*(n+1)-1) * z * V(n,0) - (n) * V(n-1,0) ) / (n+1);
        W(n+1,0) = 0.0;
    }

    for (int m = 0; m < nmax ; m++)
    {
        V(m+1,m+1) = (2*(m +1)-1) * (x*V(m,m) - y*W(m,m));
        W(m+1,m+1) = (2*(m +1)-1) * (x*W(m,m) + y*V(m,m));

        if(m < (nmax - 1)) {
            
            V(m+2,m+1) = (2*(m+1)+1) * z * V(m+1,m+1);
            W(m+2,m+1) = (2*(m+1)+1) * z * W(m+1,m+1);
        }

        for (int n = m+1; n < nmax; n++)
        {
            V(n+1,m+1) = ((2*(n+1)-1)*z*V(n,m+1) - (n+m+1)*V(n-1,m+1)) / ((n+1)-(m+1));
            W(n+1,m+1) = ((2*(n+1)-1)*z*W(n,m+1) - (n+m+1)*W(n-1,m+1)) / ((n+1)-(m+1));
        }
        
    }


    this->V = V;
    this->W = W;
    this->lat = lat;
    this->lon = lon;
    


    // hysdrostatic

    double ahm = 0;
    double aha = 0;
    double awm = 0;
    double awa = 0;

    int i = 0;

    
    for (int n = 0; n < V.n_rows; n++) {
        
        for(int m = 0; m <= n; m++){
                
            ahm = ahm + (ah_mean(i)*V(n,m) + bh_mean(i)*W(n,m));
            aha = aha + (ah_amp(i) *V(n,m) + bh_amp(i) *W(n,m));
            awm = awm + (aw_mean(i)*V(n,m) + bw_mean(i)*W(n,m));
            awa = awa + (aw_amp(i) *V(n,m) + bw_amp(i) *W(n,m));
            i++;
        }
    }

        for (int n = 0; n < nmax + 1; n++)
        {   
            for (int m = 0; i <= n; m++)
            {
                ahm = ahm + (ah_mean(i)*V(n,m) + bh_mean(i)*W(n,m));
                aha = aha + (ah_amp(i) *V(n,m) + bh_amp(i) *W(n,m));
                awm = awm + (aw_mean(i)*V(n,m) + bw_mean(i)*W(n,m));
                awa = awa + (aw_amp(i) *V(n,m) + bw_amp(i) *W(n,m));

                i = i+1;
            }
            
        }
        
        this->ahm = ahm;
        this->aha = aha;
        this->awm = awm;
        this->awa = awa;
    }


    // Computation start

        double aw = (awm + awa*cos(doy*2*pi))*1e-5;
        double ah  = (ahm + aha*cos(doy*2*pi))*1e-5;

        double phi_h,c11_h,c10_h;
    
        if (lat<0) {      // southern hemisphere
                phi_h  = pi;
                c11_h = 0.007;
                c10_h = 0.002;
        
        } else {          // northern hemisphere
                phi_h  = 0;
                c11_h = 0.005;
                c10_h = 0.001;
        }

        double c0_h = 0.062;
        // hidrostatic b form Isobaric mapping function
        double bh = 0.002905;
        // c hydrostatic is taken from equation (7) in [1]
        double ch = c0_h + ((cos((doy - 28) / 365.25 * 2 * pi + phi_h) + 1) * c11_h / 2 + c10_h)*(1 - cos(lat));
        //wet b and c form Niell mapping function at 45Ã¿ lat tab 4 in [3]
        double bw = 0.00146;
        double cw = 0.04391;

        // Compute mapping functions
        // Ausiliary vectors
        vec ah_v(el.n_elem);
        ah_v.fill(ah);
        vec ch_v(el.n_elem);
        ch_v.fill(ch);
        vec aw_v(el.n_elem);
        aw_v.fill(aw);

        gmfh = mfContinuedFractionForm(ah_v,bh,ch_v,el);
        gmfw = mfContinuedFractionForm(aw_v,bw,cw,el);
        
        // correct hydrostatic for height
        vec ht_corr = hydrostaticMFHeigthCorrection(hgt,el);
    
        gmfh.replace(datum::nan,0);
        ht_corr.replace(datum::nan,0);

        gmfh = (gmfh + ht_corr);
        gmfh = (gmfh + ht_corr);
        
        //vec gmf = gmfh + gmfw;

        return make_tuple(gmfh,gmfw);
                
  }

  
vec Atmo::getIonoMF(double lat, double h, vec el, double rcm = NULL){
    if(rcm == NULL){

        rcm = getRcm();

    }

    double thin_shell_height = getThinShellHeight();

    el.transform([](double val) {if((val != datum::nan) && (val >= 0) ) {return (cos(val));}else {return val = datum::nan;}});
    vec iono_mf = (rcm + h) / (rcm + h + thin_shell_height) * el;
    iono_mf.for_each ( [] (double& val) {val = (pow(1 - (pow(val,2)),(-0.5))); });
    
    return iono_mf;
    
    }


    double Atmo::getThinShellHeight(){

        double thin_shell_height;

        if(this->ionex.height.empty()){
            thin_shell_height = 350 * 1e3; // if the ionex is not loaded use 350km
        } else {
            thin_shell_height = this->ionex.height[0] * 1e3;     // ionopshere thin shell height [km]
        }
        return thin_shell_height;
    }

    vec Atmo::mfContinuedFractionForm(vec a,double b,vec c,vec el)
    {   
        vec sine = sin(el);
        vec delay = (1 + (a / (1 + (b / (1 + c) )))) / (sine + (a / (sine + (b / (sine + c) ))));
        
        return delay;
    }
    vec Atmo::mfContinuedFractionForm(vec a,double b,double c, vec el)
    {   
        vec sine = sin(el);
        vec delay = (1 + (a / (1 + (b / (1 + c) )))) / (sine + (a / (sine + (b / (sine + c) ))));
        
        return delay;
    }
    vec Atmo::mfContinuedFractionForm(double a,double b,double c,vec el)
    {   
        vec sine = sin(el);
        vec delay = (1 + (a / (1 + (b / (1 + c) )))) / (sine + (a / (sine + (b / (sine + c) ))));
        
        return delay;
    }

    vec Atmo::hydrostaticMFHeigthCorrection(double h_ell, vec el)
    {
        // coorect the hysdrostatic mapping functions for the height
        // formulas and paramaters taken from :
        // Niell, A. E. "Global mapping functions for the atmosphere delay at radio wavelengths.
        // " Journal of Geophysical Research: Solid Earth 101.B2 (1996): 3227-3246.
        
        // height correction for the hydrostatic part

        // coefficent from tab 3
        double a_ht = 2.53e-5;
        double b_ht = 5.49e-3;
        double c_ht = 1.14e-3;
        double h_ell_km = h_ell/1000;   // convert height to km
        // eq (6)
        vec ht_corr_coef = 1 / sin(el) - mfContinuedFractionForm(a_ht,b_ht,c_ht,el);
        // eq (7)
        vec ht_corr = ht_corr_coef * h_ell_km;
    
        return ht_corr;

    }




